В этой статье рассмотрим жизненный цикл ViewController'a. Посмотрим когда вызываются методы и что можно делать внутри них. Так же рассмотрим частые ошибки.

Начнем с `UIView`. Он ведет себя предсказуемо, как только вызвали инициализатор - выделяется память. Теперь проперти имеют значения и объект можно использовать.

У контроллера есть вью. Но то, что контроллер создан, не означает что вью создана тоже. Система ждет повод создать её. Концепция жизненного цикла строится вокруг этой особенности. Просто держите в уме, что вью создается по необходимости.

## Инициализируем

Рассмотрим базовый `UIViewController`, инициализаторов два:

```swift
override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
}
    
required init?(coder: NSCoder) {
    super.init(coder: coder)
}
```

Ещё есть инициализатор без параметров `init()`, но это обертка над первым иницициализатором.

На этом этапе контроллер ведет себя как обычный класс: инициализирует проперти, отрабатывает тело инициализатора. Контроллер может быть долго в состоянии без загруженной вью, а может даже никогда не загрузить ее. Вью загрузится как только система или разработчик обратится к проперти `.view`.

## Загружаем

Разработчик презентует контроллер. Для системы это повод загрузить вью - выделяется память. Мы можем следить за процессом и даже вмешаться. Глянем какие методы доступны:

```swift
override func loadView() {}
```

Метод `loadView()` вызывается системой. Его не нужно вызывать вручную, но можно переопределить, чтобы подменить корневую вью. Если нужно загрузить вью вручную (и вы знаете что делаете), то держите красную кнопку `loadViewIfNeeded()`.

> `super.loadView()` не нужно.

Второй метод легендарен, как Стив Джобс. Он вызывается когда вью закончила загрузку.

```swift
override viewDidLoad() {
    super.viewDidLoad()
}
```

Разработчики не просто так делают настройку контроллера и вьюх в методе `viewDidLoad()`. До вызова этого метода корневая вью еще не существует, а после контроллер уже готов появиться на экране. `viewDidLoad()` - отличное место. Память под вью выделена, вью загружена и готова к настройке.

Вью нельзя настраивать в инициализаторе. При обращении к `.view` она загрузится, но контроллер появится на экране не сейчас (а может вообще не появится). Проект от такого не крашнется, но элементы интерфейса расходуют много памяти и она потратится раньше, чем нужно. Лучше делать это по необходимости.

Раньше я делал проперти-вьюхи контроллера просто создавая их:

```swift
class ViewController: UIViewController {
    
    var redView = UIView()
}
```

Проперти инициализируется вместе с контроллером, а значит память для вью выделится сразу. Чтобы отложить это до требования, нужно пометить проперти как `lazy`.

В методе `viewDidLoad()` размеры вьюхи неверные, привязываться к высоте и ширине нельзя. Делайте настройку, которая не зависят от размеров.

Хочу остановиться на `viewDidUnload()`. Корневая вью может выгружаться из памяти, а это означает кое-что невероятное:

>Метод `viewDidLoad()` может вызываться несколько раз.

Например, если модальный контроллер закрыть, вью выгрузится из памяти, но объект контроллера еще будет жив. Если показать контроллер еще раз - вью снова загрузится. Если система выгрузила вью, значит был повод. Не нужно обращаться к корневой вью в этом методе - это вызовет ее загрузку. Аутлеты здесь активны, но уже не имеют смысла - их можно ресетить.

Не нужно срочно брать внеурочные и все выходные переделывать вашу VPN-ку. Ничего не сломается, `viewDidLoad()` редко вызывается несколько раз. Держите в уме, что нужно разнести настройку данных и вьюх в следующем проекте.

## Показываем

Появление контроллера начинается с метода `viewWillAppear`:

```swift
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
}
    
override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
}
```

Оба метода в связке. Тут делать настройку не нужно, но можно спрятать/показать вьюхи или добавить несложное поведение. В методе `viewDidAppear()` начинайте сетевой запрос или крутите индикатор загрузки. Оба метода могут вызываться несколько раз.

Есть методы, которые сообщают что вью пропадает с экрана. Наглядная схема:

![ViewController LifeCycle](https://cdn.ivanvorobei.by/websites/sparrowcode.io/uiviewcontroller-lifecycle/header.jpg)

Обратите внимание на пару антагонистов `viewWillDisappear()` и `viewDidDisappear`. Они вызываются, когда вью удаляется из иерархии представлений. Если вы показываете другой контроллер поверх, то методы не вызываются.

## Layout

Методы лейаута, аналогично методам выше, подвязаны к жизненному циклу вьюхи. Доступно 3 метода:

```swift
override func viewWillLayoutSubviews() {
    super.viewWillLayoutSubviews()
}
    
override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()
}
```

Первый метод вызывается до `layoutSubviews()` корневой вью, второй - после. Во втором методе размеры корректные, а вью размещены правильно - можно подвязываться к размерам корневой вью.

Есть отдельный метод про изменение размеров вью. Это не обязательно поворот устройства, хотя он тоже:

```swift
override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
    super.viewWillTransition(to: size, with: coordinator)
}
```

После будут вызваны методы `viewWillLayoutSubviews()` и `viewDidLayoutSubviews()`.

## Кончается память

Вызывается, если память переполняется. Если вы не очистите объекты, из-за которых это происходит, iOS принудительно выключит приложение (для пользователя будет выглядеть как краш).

```swift
override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
```

На этом всё. Жизненный цикл контроллера большая тема, я мог что-то упустить. Дайте мне знать если нашли что-то или есть хороший пример для статьи.

